/* jshint ignore:start */

/* jshint ignore:end */

define('dummy/app', ['exports', 'ember', 'ember/resolver', 'ember/load-initializers', 'dummy/config/environment'], function (exports, Ember, Resolver, loadInitializers, config) {

  'use strict';

  var App;

  Ember['default'].MODEL_FACTORY_INJECTIONS = true;

  App = Ember['default'].Application.extend({
    modulePrefix: config['default'].modulePrefix,
    podModulePrefix: config['default'].podModulePrefix,
    Resolver: Resolver['default']
  });

  loadInitializers['default'](App, config['default'].modulePrefix);

  exports['default'] = App;

});
define('dummy/controllers/foo', ['exports', 'ember', 'ember-validations'], function (exports, Ember, EmberValidations) {

  'use strict';

  exports['default'] = Ember['default'].Controller.extend(EmberValidations['default'], {
    validations: {
      foo: {
        presence: true
      },

      bar: {
        presence: true,
        length: { minimum: 5 }
      },

      baz: {
        presence: {
          'if': 'isBaz'
        }
      }
    }
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/errors.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations');
  test('modules/ember-validations/errors.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/errors.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/index.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations');
  test('modules/ember-validations/index.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/index.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/messages.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations');
  test('modules/ember-validations/messages.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/messages.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/mixin.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations');
  test('modules/ember-validations/mixin.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/mixin.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/patterns.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations');
  test('modules/ember-validations/patterns.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/patterns.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/base.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators');
  test('modules/ember-validations/validators/base.js should pass jshint', function () {
    ok(false, 'modules/ember-validations/validators/base.js should pass jshint.\nmodules/ember-validations/validators/base.js: line 3, col 7, \'get\' is defined but never used.\nmodules/ember-validations/validators/base.js: line 4, col 7, \'set\' is defined but never used.\n\n2 errors');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/local/absence.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators/local');
  test('modules/ember-validations/validators/local/absence.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/validators/local/absence.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/local/acceptance.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators/local');
  test('modules/ember-validations/validators/local/acceptance.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/validators/local/acceptance.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/local/confirmation.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators/local');
  test('modules/ember-validations/validators/local/confirmation.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/validators/local/confirmation.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/local/exclusion.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators/local');
  test('modules/ember-validations/validators/local/exclusion.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/validators/local/exclusion.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/local/format.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators/local');
  test('modules/ember-validations/validators/local/format.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/validators/local/format.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/local/inclusion.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators/local');
  test('modules/ember-validations/validators/local/inclusion.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/validators/local/inclusion.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/local/length.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators/local');
  test('modules/ember-validations/validators/local/length.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/validators/local/length.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/local/numericality.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators/local');
  test('modules/ember-validations/validators/local/numericality.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/validators/local/numericality.js should pass jshint.');
  });

});
define('dummy/ember-validations/tests/modules/ember-validations/validators/local/presence.jshint', function () {

  'use strict';

  module('JSHint - modules/ember-validations/validators/local');
  test('modules/ember-validations/validators/local/presence.js should pass jshint', function () {
    ok(true, 'modules/ember-validations/validators/local/presence.js should pass jshint.');
  });

});
define('dummy/initializers/app-version', ['exports', 'dummy/config/environment', 'ember'], function (exports, config, Ember) {

  'use strict';

  var classify = Ember['default'].String.classify;
  var registered = false;

  exports['default'] = {
    name: 'App Version',
    initialize: function initialize(container, application) {
      if (!registered) {
        var appName = classify(application.toString());
        Ember['default'].libraries.register(appName, config['default'].APP.version);
        registered = true;
      }
    }
  };

});
define('dummy/initializers/export-application-global', ['exports', 'ember', 'dummy/config/environment'], function (exports, Ember, config) {

  'use strict';

  exports.initialize = initialize;

  function initialize(container, application) {
    var classifiedName = Ember['default'].String.classify(config['default'].modulePrefix);

    if (config['default'].exportApplicationGlobal && !window[classifiedName]) {
      window[classifiedName] = application;
    }
  }

  ;

  exports['default'] = {
    name: 'export-application-global',

    initialize: initialize
  };

});
define('dummy/models/user', ['exports', 'ember'], function (exports, Ember) {

	'use strict';

	exports['default'] = Ember['default'].Object.extend();

});
define('dummy/router', ['exports', 'ember', 'dummy/config/environment'], function (exports, Ember, config) {

  'use strict';

  var Router = Ember['default'].Router.extend({
    location: config['default'].locationType
  });

  Router.map(function () {});

  exports['default'] = Router;

});
define('dummy/services/validations', ['exports', 'ember'], function (exports, Ember) {

  'use strict';

  var set = Ember['default'].set;

  exports['default'] = Ember['default'].Service.extend({
    init: function init() {
      set(this, 'cache', {});
    }
  });

});
define('dummy/templates/application', ['exports'], function (exports) {

  'use strict';

  exports['default'] = Ember.HTMLBars.template((function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.0",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("h2");
        dom.setAttribute(el1,"id","title");
        var el2 = dom.createTextNode("Welcome to Ember.js");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,2,2,contextualElement);
        content(env, morph0, context, "outlet");
        return fragment;
      }
    };
  }()));

});
define('dummy/tests/app.jshint', function () {

  'use strict';

  module('JSHint - .');
  test('app.js should pass jshint', function() { 
    ok(true, 'app.js should pass jshint.'); 
  });

});
define('dummy/tests/controllers/foo.jshint', function () {

  'use strict';

  module('JSHint - controllers');
  test('controllers/foo.js should pass jshint', function() { 
    ok(true, 'controllers/foo.js should pass jshint.'); 
  });

});
define('dummy/tests/helpers/build-container', ['exports', 'ember', 'dummy/tests/helpers/resolver'], function (exports, Ember, resolver) {

  'use strict';



  exports['default'] = buildContainer;

  function buildContainer() {
    return new Ember['default'].Container(buildRegistry());
  }

  function buildRegistry() {
    var registry = new Ember['default'].Registry();
    registry.resolver = buildResolver();
    registry.normalizeFullName = registry.resolver.normalize;
    registry.describe = registry.resolver.describe;
    registry.makeToString = registry.resolver.makeToString;

    return registry;
  }

  function buildResolver() {
    function resolve(fullname) {
      return resolver['default'].resolve(fullname);
    }

    resolve.describe = function (fullName) {
      return resolver['default'].lookupDescription(fullName);
    };

    resolve.makeToString = function (factory, fullName) {
      return resolver['default'].makeToString(factory, fullName);
    };

    resolve.normalize = function (fullName) {
      if (resolver['default'].normalize) {
        return resolver['default'].normalize(fullName);
      } else {
        return fullName;
      }
    };

    resolve.__resolver__ = resolver['default'];

    return resolve;
  }

});
define('dummy/tests/helpers/resolver', ['exports', 'ember/resolver', 'dummy/config/environment'], function (exports, Resolver, config) {

  'use strict';

  var resolver = Resolver['default'].create();

  resolver.namespace = {
    modulePrefix: config['default'].modulePrefix,
    podModulePrefix: config['default'].podModulePrefix
  };

  exports['default'] = resolver;

});
define('dummy/tests/helpers/resolver.jshint', function () {

  'use strict';

  module('JSHint - helpers');
  test('helpers/resolver.js should pass jshint', function() { 
    ok(true, 'helpers/resolver.js should pass jshint.'); 
  });

});
define('dummy/tests/helpers/start-app', ['exports', 'ember', 'dummy/app', 'dummy/router', 'dummy/config/environment'], function (exports, Ember, Application, Router, config) {

  'use strict';



  exports['default'] = startApp;
  function startApp(attrs) {
    var application;

    var attributes = Ember['default'].merge({}, config['default'].APP);
    attributes = Ember['default'].merge(attributes, attrs); // use defaults, but you can override;

    Ember['default'].run(function () {
      application = Application['default'].create(attributes);
      application.setupForTesting();
      application.injectTestHelpers();
    });

    return application;
  }

});
define('dummy/tests/helpers/start-app.jshint', function () {

  'use strict';

  module('JSHint - helpers');
  test('helpers/start-app.js should pass jshint', function() { 
    ok(true, 'helpers/start-app.js should pass jshint.'); 
  });

});
define('dummy/tests/helpers/validate-properties', ['exports', 'ember', 'ember-qunit'], function (exports, Ember, ember_qunit) {

  'use strict';

  exports.testValidPropertyValues = testValidPropertyValues;
  exports.testInvalidPropertyValues = testInvalidPropertyValues;

  var forEach = Ember['default'].EnumerableUtils.forEach;
  var run = Ember['default'].run;

  function validateValues(object, propertyName, values, isTestForValid) {
    var promise = null;
    var validatedValues = [];

    forEach(values, function (value) {
      function handleValidation(errors) {
        var hasErrors = object.get('errors.' + propertyName + '.firstObject');
        if (hasErrors && !isTestForValid || !hasErrors && isTestForValid) {
          validatedValues.push(value);
        }
      }

      run(object, 'set', propertyName, value);

      var objectPromise = null;
      run(function () {
        objectPromise = object.validate().then(handleValidation, handleValidation);
      });

      // Since we are setting the values in a different run loop as we are validating them,
      // we need to chain the promises so that they run sequentially. The wrong value will
      // be validated if the promises execute concurrently
      promise = promise ? promise.then(objectPromise) : objectPromise;
    });

    return promise.then(function () {
      return validatedValues;
    });
  }

  function testPropertyValues(propertyName, values, isTestForValid, context) {
    var validOrInvalid = isTestForValid ? 'Valid' : 'Invalid';
    var testName = validOrInvalid + ' ' + propertyName;

    ember_qunit.test(testName, function (assert) {
      var object = this.subject();

      if (context && typeof context === 'function') {
        context(object);
      }

      // Use QUnit.dump.parse so null and undefined can be printed as literal 'null' and
      // 'undefined' strings in the assert message.
      var valuesString = QUnit.dump.parse(values).replace(/\n(\s+)?/g, '').replace(/,/g, ', ');
      var assertMessage = 'Expected ' + propertyName + ' to have ' + validOrInvalid.toLowerCase() + ' values: ' + valuesString;

      return validateValues(object, propertyName, values, isTestForValid).then(function (validatedValues) {
        assert.deepEqual(validatedValues, values, assertMessage);
      });
    });
  }
  function testValidPropertyValues(propertyName, values, context) {
    testPropertyValues(propertyName, values, true, context);
  }

  function testInvalidPropertyValues(propertyName, values, context) {
    testPropertyValues(propertyName, values, false, context);
  }

});
define('dummy/tests/models/user.jshint', function () {

  'use strict';

  module('JSHint - models');
  test('models/user.js should pass jshint', function() { 
    ok(true, 'models/user.js should pass jshint.'); 
  });

});
define('dummy/tests/router.jshint', function () {

  'use strict';

  module('JSHint - .');
  test('router.js should pass jshint', function() { 
    ok(true, 'router.js should pass jshint.'); 
  });

});
define('dummy/tests/test-helper', ['dummy/tests/helpers/resolver', 'ember-qunit'], function (resolver, ember_qunit) {

	'use strict';

	ember_qunit.setResolver(resolver['default']);

});
define('dummy/tests/test-helper.jshint', function () {

  'use strict';

  module('JSHint - .');
  test('test-helper.js should pass jshint', function() { 
    ok(true, 'test-helper.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/conditional-validators-test', ['ember', 'qunit', 'ember-validations/mixin', 'dummy/tests/helpers/build-container'], function (Ember, qunit, Mixin, buildContainer) {

  'use strict';

  var user, User, promise;
  var get = Ember['default'].get;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Conditional validations', {
    setup: function setup() {
      User = Ember['default'].Object.extend(Mixin['default'], {
        container: buildContainer['default']()
      });
    }
  });

  qunit.test('if with function', function (assert) {
    assert.expect(4);
    User.reopen({
      validations: {
        firstName: {
          presence: {
            'if': function _if(model) {
              return false;
            }
          }
        }
      }
    });

    run(function () {
      user = User.create();
      promise = user.validate().then(function () {
        assert.ok(Ember['default'].isEmpty(get(user.errors, 'firstName')));
        var validator = get(user.validators, 'firstObject');
        validator.conditionals['if'] = function (model, property) {
          assert.equal(user, model, 'the conditional validator is passed the model being validated');
          assert.equal(property, 'firstName', 'the conditional validator is passed the name of the property being validated');
          return true;
        };
        user.validate().then(null, function () {
          assert.deepEqual(get(user.errors, 'firstName'), ['can\'t be blank']);
        });
      });
    });

    return promise;
  });

  qunit.test('if with property reference', function (assert) {
    User.reopen({
      validations: {
        firstName: {
          presence: {
            'if': 'canValidate'
          }
        }
      }
    });

    run(function () {
      user = User.create();
      set(user, 'canValidate', false);
      promise = user.validate().then(function () {
        assert.ok(Ember['default'].isEmpty(get(user.errors, 'firstName')));
        set(user, 'canValidate', true);
        user.validate().then(null, function () {
          assert.deepEqual(get(user.errors, 'firstName'), ['can\'t be blank']);
        });
      });
    });

    return promise;
  });

  qunit.test('if with function reference', function (assert) {
    User.reopen({
      validations: {
        firstName: {
          presence: {
            'if': 'canValidate'
          }
        }
      },
      canValidate: function canValidate() {
        return false;
      }
    });

    run(function () {
      user = User.create();
      promise = user.validate().then(function () {
        assert.ok(Ember['default'].isEmpty(get(user.errors, 'firstName')));
        set(user, 'canValidate', true);
        user.canValidate = function () {
          return true;
        };
        user.validate().then(null, function () {
          assert.deepEqual(get(user.errors, 'firstName'), ['can\'t be blank']);
        });
      });
    });

    return promise;
  });

  qunit.test('unless with function', function (assert) {
    assert.expect(4);
    User.reopen({
      validations: {
        firstName: {
          presence: {
            unless: function unless(model) {
              return true;
            }
          }
        }
      }
    });

    run(function () {
      user = User.create();
      promise = user.validate().then(function () {
        assert.ok(Ember['default'].isEmpty(get(user.errors, 'firstName')));
        var validator = get(user.validators, 'firstObject');
        validator.conditionals['unless'] = function (model, property) {
          assert.equal(user, model, 'the conditional validator is passed the model being validated');
          assert.equal(property, 'firstName', 'the conditional validator is passed the name of the property being validated');
          return false;
        };
        user.validate().then(null, function () {
          assert.deepEqual(get(user.errors, 'firstName'), ['can\'t be blank']);
        });
      });
    });

    return promise;
  });

  qunit.test('unless with property reference', function (assert) {
    User.reopen({
      validations: {
        firstName: {
          presence: {
            unless: 'canValidate'
          }
        }
      },
      canValidate: true
    });

    run(function () {
      user = User.create();
      promise = user.validate().then(function () {
        assert.ok(Ember['default'].isEmpty(get(user.errors, 'firstName')));
        set(user, 'canValidate', false);
        user.validate().then(null, function () {
          assert.deepEqual(get(user.errors, 'firstName'), ['can\'t be blank']);
        });
      });
    });

    return promise;
  });

  qunit.test('unless with function reference', function (assert) {
    User.reopen({
      validations: {
        firstName: {
          presence: {
            unless: 'canValidate'
          }
        }
      },
      canValidate: function canValidate() {
        return true;
      }
    });

    run(function () {
      user = User.create();
      promise = user.validate().then(function () {
        assert.ok(Ember['default'].isEmpty(get(user.errors, 'firstName')));
        set(user, 'canValidate', true);
        user.canValidate = function () {
          return false;
        };
        user.validate().then(null, function () {
          assert.deepEqual(get(user.errors, 'firstName'), ['can\'t be blank']);
        });
      });
    });

    return promise;
  });

});
define('dummy/tests/unit/conditional-validators-test.jshint', function () {

  'use strict';

  module('JSHint - unit');
  test('unit/conditional-validators-test.js should pass jshint', function() { 
    ok(true, 'unit/conditional-validators-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/controller-test', ['ember-qunit'], function (ember_qunit) {

  'use strict';

  ember_qunit.moduleFor('controller:foo', 'Controller sanity test', {
    needs: ['ember-validations@validator:local/presence']
  });

  ember_qunit.test('does not blow up', function (assert) {
    var controller = this.subject();
    assert.ok(controller);
  });

});
define('dummy/tests/unit/controller-test.jshint', function () {

  'use strict';

  module('JSHint - unit');
  test('unit/controller-test.js should pass jshint', function() { 
    ok(true, 'unit/controller-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/errors-test', ['ember', 'qunit', 'ember-validations/mixin', 'dummy/tests/helpers/build-container'], function (Ember, qunit, Mixin, buildContainer) {

  'use strict';

  var user, User;
  var get = Ember['default'].get;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Errors test', {
    setup: function setup() {
      User = Ember['default'].Object.extend(Mixin['default'], {
        container: buildContainer['default'](),
        validations: {
          name: {
            presence: true
          },
          age: {
            presence: true,
            numericality: true
          }
        }
      });
    },
    teardown: function teardown() {
      delete Ember['default'].I18n;
    }
  });

  qunit.test('validations are run on instantiation', function (assert) {
    run(function () {
      user = User.create();
    });
    assert.equal(get(user, 'isValid'), false);
    assert.deepEqual(get(user, 'errors.name'), ['can\'t be blank']);
    assert.deepEqual(get(user, 'errors.age'), ['can\'t be blank', 'is not a number']);
    run(function () {
      user = User.create({ name: 'Brian', age: 33 });
    });
    assert.ok(get(user, 'isValid'));
    assert.ok(Ember['default'].isEmpty(get(user, 'errors.name')));
    assert.ok(Ember['default'].isEmpty(get(user, 'errors.age')));
  });

  qunit.test('when errors are resolved', function (assert) {
    run(function () {
      user = User.create();
    });
    assert.equal(get(user, 'isValid'), false);
    assert.deepEqual(get(user, 'errors.name'), ['can\'t be blank']);
    assert.deepEqual(get(user, 'errors.age'), ['can\'t be blank', 'is not a number']);
    run(function () {
      set(user, 'name', 'Brian');
    });
    assert.equal(get(user, 'isValid'), false);
    assert.ok(Ember['default'].isEmpty(get(user, 'errors.name')));
    assert.deepEqual(get(user, 'errors.age'), ['can\'t be blank', 'is not a number']);
    run(function () {
      set(user, 'age', 'thirty three');
    });
    assert.equal(get(user, 'isValid'), false);
    assert.ok(Ember['default'].isEmpty(get(user, 'errors.name')));
    assert.deepEqual(get(user, 'errors.age'), ['is not a number']);
    run(function () {
      set(user, 'age', 33);
    });
    assert.ok(get(user, 'isValid'));
    assert.ok(Ember['default'].isEmpty(get(user, 'errors.name')));
    assert.ok(Ember['default'].isEmpty(get(user, 'errors.age')));
  });

  // test('validations use Ember.I18n.t to render the message if Ember.I18n is present', function() {
  // Ember.I18n = {
  // translations: {
  // errors: {
  // blank: 'muss ausgefüllt werden',
  // notANumber: 'ist keine Zahl'
  // }
  // },
  // lookupKey: function(key, hash) {
  // var firstKey, idx, remainingKeys;

  // if (hash[key] !== null && hash[key] !== undefined) { return hash[key]; }

  // if ((idx = key.indexOf('.')) !== -1) {
  // firstKey = key.substr(0, idx);
  // remainingKeys = key.substr(idx + 1);
  // hash = hash[firstKey];
  // if (hash) { return Ember.I18n.lookupKey(remainingKeys, hash); }
  // }
  // },
  // t: function(key, context) {
  // return Ember.I18n.lookupKey(key, Ember.I18n.translations);
  // }
  // };

  // run(function() {
  // user = User.create();
  // });
  // equal(get(user, 'isValid'), false);
  // assert.deepEqual(get(user, 'errors.name'), ['muss ausgefüllt werden']);
  // assert.deepEqual(get(user, 'errors.age'), ['muss ausgefüllt werden', 'ist keine Zahl']);
  // run(function() {
  // set(user, 'age', 'thirty three');
  // });
  // equal(get(user, 'isValid'), false);
  // assert.deepEqual(get(user, 'errors.age'), ['ist keine Zahl']);
  // });

});
define('dummy/tests/unit/errors-test.jshint', function () {

  'use strict';

  module('JSHint - unit');
  test('unit/errors-test.js should pass jshint', function() { 
    ok(true, 'unit/errors-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/helpers/validate-properties-test', ['ember-qunit', 'dummy/tests/helpers/validate-properties'], function (ember_qunit, validate_properties) {

  'use strict';

  var _deepEqual;

  ember_qunit.moduleFor('controller:foo', 'Unit - Foo Controller Test', {
    needs: ['ember-validations@validator:local/presence', 'ember-validations@validator:local/length']
  });

  validate_properties.testValidPropertyValues('bar', ['Winston', '12345']);

  validate_properties.testInvalidPropertyValues('bar', ['', null, undefined, 'abc']);

  validate_properties.testValidPropertyValues('baz', ['Winston', '12345'], function (subject) {
    subject.set('isBaz', true);
  });

  validate_properties.testInvalidPropertyValues('baz', ['', null, undefined], function (subject) {
    subject.set('isBaz', true);
  });

  validate_properties.testValidPropertyValues('baz', ['Winston', '12345', null, undefined, ''], function (subject) {
    subject.set('isBaz', false);
  });

  ember_qunit.moduleFor('controller:foo', 'Unit - Ensure validate properties test helpers fail when invalid', {
    needs: ['ember-validations@validator:local/presence', 'ember-validations@validator:local/length'],

    beforeEach: function beforeEach(assert) {
      // use inverse of deepEqual to ensure the test helpers fail when invalid
      assert.deepEqual = assert.notDeepEqual;
    }
  });

  validate_properties.testValidPropertyValues('bar', [undefined, 'Winston', '12345']);
  validate_properties.testValidPropertyValues('bar', ['Winston', undefined, '12345']);
  validate_properties.testValidPropertyValues('bar', ['Winston', '12345', undefined]);

  validate_properties.testInvalidPropertyValues('bar', ['', null, undefined, 'abc', 'Winston']);
  validate_properties.testInvalidPropertyValues('bar', ['Winston', null, undefined, 'abc']);
  validate_properties.testInvalidPropertyValues('bar', [null, 'Winston', undefined, 'abc']);

  validate_properties.testInvalidPropertyValues('baz', ['Winston', '12345'], function (subject) {
    subject.set('isBaz', true);
  });

  validate_properties.testValidPropertyValues('baz', [undefined, 'Winston', '12345'], function (subject) {
    subject.set('isBaz', true);
  });
  validate_properties.testValidPropertyValues('baz', ['Winston', '12345', undefined], function (subject) {
    subject.set('isBaz', true);
  });
  validate_properties.testValidPropertyValues('baz', ['Winston', undefined, '12345'], function (subject) {
    subject.set('isBaz', true);
  });

  validate_properties.testInvalidPropertyValues('baz', ['', null, undefined, 'Winston'], function (subject) {
    subject.set('isBaz', true);
  });
  validate_properties.testInvalidPropertyValues('baz', ['Winston', null, undefined], function (subject) {
    subject.set('isBaz', true);
  });
  validate_properties.testInvalidPropertyValues('baz', ['', null, 'Winston', undefined], function (subject) {
    subject.set('isBaz', true);
  });

  validate_properties.testInvalidPropertyValues('baz', ['Winston', '12345', null, undefined, ''], function (subject) {
    subject.set('isBaz', false);
  });

});
define('dummy/tests/unit/helpers/validate-properties-test.jshint', function () {

  'use strict';

  module('JSHint - unit/helpers');
  test('unit/helpers/validate-properties-test.js should pass jshint', function() { 
    ok(true, 'unit/helpers/validate-properties-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validate-test', ['ember', 'qunit', 'ember-validations', 'dummy/tests/helpers/build-container', 'ember-validations/validators/base'], function (Ember, qunit, ember_validations, buildContainer, Base) {

  'use strict';

  var user, User, promise;
  var get = Ember['default'].get;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Validate test', {
    setup: function setup() {
      User = Ember['default'].Object.extend(ember_validations['default'], {
        container: buildContainer['default'](),
        validations: {
          firstName: {
            presence: true,
            length: 5
          },
          lastName: {
            format: { 'with': /\w+/ }
          }
        }
      });
      run(function () {
        user = User.create();
      });
    }
  });

  qunit.test('returns a promise', function (assert) {
    run(function () {
      promise = user.validate().then(function () {
        assert.ok(false, 'expected validation failed');
      }, function () {
        assert.equal(get(user, 'isValid'), false);
      });
    });

    return promise;
  });

  qunit.test('isInvalid tracks isValid', function (assert) {
    assert.equal(get(user, 'isInvalid'), true);
    run(function () {
      user.setProperties({ firstName: 'Brian', lastName: 'Cardarella' });
    });
    assert.equal(get(user, 'isInvalid'), false);
  });

  qunit.test('runs all validations', function (assert) {
    run(function () {
      promise = user.validate().then(null, function (errors) {
        assert.deepEqual(get(errors, 'firstName'), ['can\'t be blank', 'is the wrong length (should be 5 characters)']);
        assert.deepEqual(get(errors, 'lastName'), ['is invalid']);
        assert.equal(get(user, 'isValid'), false);
        set(user, 'firstName', 'Bob');
        user.validate('firstName').then(null, function (errors) {
          assert.deepEqual(get(errors, 'firstName'), ['is the wrong length (should be 5 characters)']);
          assert.equal(get(user, 'isValid'), false);
          set(user, 'firstName', 'Brian');
          set(user, 'lastName', 'Cardarella');
          user.validate().then(function (errors) {
            assert.ok(Ember['default'].isEmpty(get(errors, 'firstName')));
            assert.ok(Ember['default'].isEmpty(get(errors, 'lastName')));
            assert.equal(get(user, 'isValid'), true);
          });
        });
      });
    });

    return promise;
  });

  qunit.test('can be mixed into an object controller', function (assert) {
    var Controller, controller, user;
    Controller = Ember['default'].ObjectController.extend(ember_validations['default'], {
      container: buildContainer['default'](),
      validations: {
        name: {
          presence: true
        }
      }
    });

    run(function () {
      controller = Controller.create();
    });
    assert.equal(get(controller, 'isValid'), false);
    user = Ember['default'].Object.create();
    run(function () {
      set(controller, 'content', user);
    });
    assert.equal(get(controller, 'isValid'), false);
    run(function () {
      set(user, 'name', 'Brian');
    });
    assert.equal(get(controller, 'isValid'), true);
  });

  qunit.module('Array controller');

  qunit.test('can be mixed into an array controller', function (assert) {
    var Controller, controller, user, UserController;
    var container = buildContainer['default']();

    UserController = Ember['default'].ObjectController.extend(ember_validations['default'], {
      container: buildContainer['default'](),
      validations: {
        name: {
          presence: true
        }
      }
    });
    container.register('controller:User', UserController);
    Controller = Ember['default'].ArrayController.extend(ember_validations['default'], {
      itemController: 'User',
      container: container,
      validations: {
        '[]': true
      }
    });

    run(function () {
      controller = Controller.create();
    });
    assert.equal(get(controller, 'isValid'), true);
    user = Ember['default'].Object.create();
    run(function () {
      controller.pushObject(user);
    });
    assert.equal(get(controller, 'isValid'), false);
    run(function () {
      set(user, 'name', 'Brian');
    });
    assert.equal(get(controller, 'isValid'), true);
    run(function () {
      set(user, 'name', undefined);
    });
    assert.equal(get(controller, 'isValid'), false);
    run(function () {
      get(controller, 'content').removeObject(user);
    });
    assert.equal(get(controller, 'isValid'), true);
  });

  var Profile, profile;

  qunit.module('Relationship validators', {
    setup: function setup() {
      Profile = Ember['default'].Object.extend(ember_validations['default'], {
        container: buildContainer['default'](),
        validations: {
          title: {
            presence: true
          }
        }
      });

      run(function () {
        profile = Profile.create({ hey: 'yo' });
      });

      User = Ember['default'].Object.extend(ember_validations['default'], {
        container: buildContainer['default']()
      });
    }
  });

  qunit.test('validates other validatable property', function (assert) {
    run(function () {
      user = User.create({
        validations: {
          profile: true
        }
      });
    });
    assert.equal(get(user, 'isValid'), true);
    run(function () {
      set(user, 'profile', profile);
    });
    assert.equal(get(user, 'isValid'), false);
    run(function () {
      set(profile, 'title', 'Developer');
    });
    assert.equal(get(user, 'isValid'), true);
  });

  // test('validates custom validator', function() {
  // run(function() {
  // user = User.create({
  // profile: profile,
  // validations: [AgeValidator]
  // });
  // });
  // equal(get(user, 'isValid'), false);
  // run(function() {
  // set(user, 'age', 22);
  // });
  // equal(get(user, 'isValid'), true);
  // });

  qunit.test('validates array of validable objects', function (assert) {
    var friend1, friend2;

    run(function () {
      user = User.create({
        validations: {
          friends: true
        }
      });
    });

    assert.equal(get(user, 'isValid'), true);

    run(function () {
      set(user, 'friends', Ember['default'].A());
    });

    assert.equal(get(user, 'isValid'), true);

    run(function () {
      friend1 = User.create({
        validations: {
          name: {
            presence: true
          }
        }
      });
    });

    run(function () {
      user.friends.pushObject(friend1);
    });

    assert.equal(get(user, 'isValid'), false);

    run(function () {
      set(friend1, 'name', 'Stephanie');
    });

    assert.equal(get(user, 'isValid'), true);

    run(function () {
      friend2 = User.create({
        validations: {
          name: {
            presence: true
          }
        }
      });

      user.friends.pushObject(friend2);
    });

    assert.equal(get(user, 'isValid'), false);

    run(function () {
      user.friends.removeObject(friend2);
    });

    assert.equal(get(user, 'isValid'), true);
  });

  qunit.test('revalidates arrays when they are replaced', function (assert) {
    var friend1, friend2;

    run(function () {
      user = User.create({
        validations: {
          friends: true
        }
      });
    });

    assert.equal(get(user, 'isValid'), true);

    run(function () {
      set(user, 'friends', Ember['default'].A());
    });

    assert.equal(get(user, 'isValid'), true);

    run(function () {
      friend1 = User.create({
        validations: {
          name: {
            presence: true
          }
        }
      });
    });

    run(function () {
      set(user, 'friends', Ember['default'].A([friend1]));
    });

    assert.equal(get(user, 'isValid'), false);

    run(function () {
      set(friend1, 'name', 'Stephanie');
    });

    assert.equal(get(user, 'isValid'), true);

    run(function () {
      friend2 = User.create({
        validations: {
          name: {
            presence: true
          }
        }
      });

      set(user, 'friends', Ember['default'].A([friend1, friend2]));
    });

    assert.equal(get(user, 'isValid'), false);

    run(function () {
      user.friends.removeObject(friend2);
    });

    assert.equal(get(user, 'isValid'), true);
  });

  /*globals define, registry, requirejs*/

  requirejs.rollback = function () {
    for (var entry in this.backupEntries) {
      this.entries[entry] = this.backupEntries[entry];
    }
  };

  requirejs.backup = function () {
    this.backupEntries = {};

    for (var entry in this.entries) {
      this.backupEntries[entry] = this.entries[entry];
    }
  };

  qunit.module('validator class lookup order', {
    setup: function setup() {
      requirejs.backup();
      requirejs.clear();
      requirejs.rollback();

      User = Ember['default'].Object.extend(ember_validations['default'], {
        container: buildContainer['default']()
      });
    },
    teardown: function teardown() {
      requirejs.clear();
      requirejs.rollback();
    }
  });

  qunit.test('should lookup in project namespace first', function (assert) {
    var dummyValidatorCalled = false;
    var nativeValidatorCalled = false;

    define('ember-validations/validators/local/presence', [], function () {
      nativeValidatorCalled = true;

      return Base['default'].extend({
        call: Ember['default'].K
      });
    });

    define('dummy/validators/local/presence', [], function () {
      dummyValidatorCalled = true;

      return Base['default'].extend({
        call: Ember['default'].K
      });
    });

    run(function () {
      user = User.create({
        validations: {
          name: {
            presence: true
          }
        }
      });
    });

    assert.ok(!nativeValidatorCalled, 'should not have preferred ember-validation\'s presence validator');
    assert.ok(dummyValidatorCalled, 'should have preferred my applications presence validator');
  });

  qunit.test('will lookup both local and remote validators of similar name', function (assert) {
    var localValidatorCalled = false;
    var remoteValidatorCalled = false;

    define('ember-validations/validators/local/uniqueness', [], function () {
      localValidatorCalled = true;

      return Base['default'].extend({
        call: Ember['default'].K
      });
    });

    define('ember-validations/validators/remote/uniqueness', [], function () {
      remoteValidatorCalled = true;

      return Base['default'].extend({
        call: Ember['default'].K
      });
    });

    run(function () {
      user = User.create({
        validations: {
          name: {
            uniqueness: true
          }
        }
      });
    });

    assert.ok(localValidatorCalled, 'should call local uniqueness validator');
    assert.ok(remoteValidatorCalled, 'should call remote uniqueness validator');
  });

  qunit.test('should prefer lookup in just "validators" before "native"', function (assert) {
    var dummyValidatorCalled = false;
    var nativeValidatorCalled = false;

    define('ember-validations/validators/local/presence', [], function () {
      nativeValidatorCalled = true;

      return Base['default'].extend({
        call: Ember['default'].K
      });
    });

    define('dummy/validators/presence', [], function () {
      dummyValidatorCalled = true;

      return Base['default'].extend({
        call: Ember['default'].K
      });
    });

    run(function () {
      user = User.create({
        validations: {
          name: {
            presence: true
          }
        }
      });
    });

    assert.ok(!nativeValidatorCalled, 'should not have preferred ember-validation\'s presence validator');
    assert.ok(dummyValidatorCalled, 'should have preferred my applications presence validator');
  });

  qunit.test('should store validators in cache for faster lookup', function (assert) {
    var validatorResolvedCount = 0;

    var container = buildContainer['default']();

    var oldLookupFactory = container.lookupFactory;

    container.lookupFactory = function (fullName) {
      validatorResolvedCount += 1;
      return oldLookupFactory.call(container, fullName);
    };

    var user2;

    run(function () {
      user = User.create({
        container: container,
        validations: {
          name: {
            presence: true
          }
        }
      });

      validatorResolvedCount = 0;

      user2 = User.create({
        container: container,
        validations: {
          name: {
            presence: true
          }
        }
      });
    });

    container.lookupFactory = oldLookupFactory;

    assert.ok(!get(user, 'isValid'));
    assert.ok(!get(user2, 'isValid'));
    assert.equal(0, validatorResolvedCount);
  });

  qunit.module('inline validations', {
    setup: function setup() {
      User = Ember['default'].Object.extend(ember_validations['default'], {
        container: buildContainer['default']()
      });
    }
  });

  qunit.test('mixed validation syntax', function (assert) {
    run(function () {
      user = User.create({
        validations: {
          name: {
            inline: ember_validations.validator(function () {
              return 'it failed';
            })
          }
        }
      });
    });

    assert.deepEqual(['it failed'], get(user, 'errors.name'));
  });

  qunit.test('concise validation syntax', function (assert) {
    run(function () {
      user = User.create({
        validations: {
          name: ember_validations.validator(function () {
            return 'it failed';
          })
        }
      });
    });

    assert.deepEqual(['it failed'], get(user, 'errors.name'));
  });

});
define('dummy/tests/unit/validate-test.jshint', function () {

  'use strict';

  module('JSHint - unit');
  test('unit/validate-test.js should pass jshint', function() { 
    ok(true, 'unit/validate-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/base-test', ['ember', 'ember-qunit'], function (Ember, ember_qunit) {

  'use strict';

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

  var model, Model, options, CustomValidator, validator;
  var get = Ember['default'].get;
  var run = Ember['default'].run;

  ember_qunit.moduleFor('ember-validations@validator:base', {
    needs: ['model:user'],
    setup: function setup() {
      var Base = this.factory('ember-validations@validator:base');

      var CustomValidator = (function (_Base) {
        function CustomValidator() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _classCallCheck(this, CustomValidator);

          _get(Object.getPrototypeOf(CustomValidator.prototype), 'constructor', this).apply(this, args);
          this.property('otherAttribute');
        }

        _inherits(CustomValidator, _Base);

        _createClass(CustomValidator, [{
          key: 'call',
          value: function call() {}
        }]);

        return CustomValidator;
      })(Base);

      ;
    }
  });

  ember_qunit.test('isValid is true when validator does not fail', function (assert) {
    var model = this.factory('model:user').create();

    var validator = undefined;
    validator = CustomValidator.create({ model: model, property: 'attribute' });

    debugger;
    get(validator, 'isValid');

    assert.equal(get(validator, 'isValid'), true);
  });

  // test('validator has isInvalid flag', function(assert) {
  // run(function() {
  // validator = CustomValidator.create({model: model, property: 'attribute'});
  // });
  // assert.equal(get(validator, 'isInvalid'), false);
  // });

  // test('generates dependentValidationKeys on the model', function(assert) {
  // run(function() {
  // validator = CustomValidator.create({model: model, property: 'attribute'});
  // });
  // assert.deepEqual(get(model, 'dependentValidationKeys'), {attribute: ['otherAttribute']});
  // });

  // test('inactive validators should be considered valid', function(assert) {
  // var canValidate = true;
  // run(function() {
  // validator = CustomValidator.createWithMixins({
  // model: model,
  // property: 'attribute',
  // canValidate: function() {
  // return canValidate;
  // },
  // call: function() {
  // this.errors.pushObject("nope");
  // }
  // });
  // });
  // assert.equal(get(validator, 'isValid'), false);
  // canValidate = false;
  // run(validator, 'validate');
  // assert.equal(get(validator, 'isValid'), true);
  // });

});
define('dummy/tests/unit/validators/base-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators');
  test('unit/validators/base-test.js should pass jshint', function() { 
    ok(false, 'unit/validators/base-test.js should pass jshint.\nunit/validators/base-test.js: line 20, col 6, Unnecessary semicolon.\nunit/validators/base-test.js: line 30, col 3, Forgotten \'debugger\' statement?\n\n2 errors'); 
  });

});
define('dummy/tests/unit/validators/local/absence-test', ['ember', 'qunit', 'ember-validations/validators/local/absence'], function (Ember, qunit, Absence) {

  'use strict';

  var model, Model, options, validator;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Absence Validator', {
    setup: function setup() {
      Model = Ember['default'].Object.extend({
        dependentValidationKeys: {}
      });
      run(function () {
        model = Model.create();
      });
    }
  });

  qunit.test('when value is not empty', function (assert) {
    options = { message: 'failed validation' };
    run(function () {
      validator = Absence['default'].create({ model: model, property: 'attribute', options: options });
    });
    assert.deepEqual(validator.errors, []);
    run(function () {
      set(model, 'attribute', 'not empty');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when value is made empty', function (assert) {
    set(model, 'attribute', 'not empty');
    options = { message: 'failed validation' };
    run(function () {
      validator = Absence['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', undefined);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when options is true', function (assert) {
    options = true;
    run(function () {
      validator = Absence['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 'not empty');
    });
    assert.deepEqual(validator.errors, ['must be blank']);
  });

});
define('dummy/tests/unit/validators/local/absence-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/local');
  test('unit/validators/local/absence-test.js should pass jshint', function() { 
    ok(true, 'unit/validators/local/absence-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/local/acceptance-test', ['ember', 'qunit', 'ember-validations/validators/local/acceptance'], function (Ember, qunit, Acceptance) {

  'use strict';

  var model, Model, options, validator;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Acceptance Validator', {
    setup: function setup() {
      Model = Ember['default'].Object.extend({
        dependentValidationKeys: {}
      });
      run(function () {
        model = Model.create();
      });
    }
  });

  qunit.test('when attribute is true', function (assert) {
    options = { message: 'failed validation' };
    run(function () {
      validator = Acceptance['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', true);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when attribute is not true', function (assert) {
    options = { message: 'failed validation' };
    run(function () {
      validator = Acceptance['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', false);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when attribute is value of 1', function (assert) {
    options = { message: 'failed validation' };
    run(function () {
      validator = Acceptance['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when attribute value is 2 and accept value is 2', function (assert) {
    options = { message: 'failed validation', accept: 2 };
    run(function () {
      validator = Acceptance['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 2);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when attribute value is 1 and accept value is 2', function (assert) {
    options = { message: 'failed validation', accept: 2 };
    run(function () {
      validator = Acceptance['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when options is true', function (assert) {
    options = true;
    run(function () {
      validator = Acceptance['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', false);
    });
    assert.deepEqual(validator.errors, ['must be accepted']);
  });

  qunit.test('when no message is passed', function (assert) {
    options = { accept: 2 };
    run(function () {
      validator = Acceptance['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', false);
    });
    assert.deepEqual(validator.errors, ['must be accepted']);
  });

});
define('dummy/tests/unit/validators/local/acceptance-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/local');
  test('unit/validators/local/acceptance-test.js should pass jshint', function() { 
    ok(true, 'unit/validators/local/acceptance-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/local/confirmation-test', ['ember', 'ember-qunit'], function (Ember, ember_qunit) {

  'use strict';

  var Model, options;
  var get = Ember['default'].get;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  ember_qunit.moduleFor('ember-validations@validator:local/confirmation', {
    needs: ['model:user']
  });

  ember_qunit.test('when values match', function (assert) {
    var model = this.factory('model:user');
    var options = {
      message: 'failed validation'
    };
    var validator = this.subject({
      model: model,
      property: 'attribute',
      options: options
    });

    assert.ok(true);

    // options = { message: 'failed validation' };
    // run(function() {
    // validator = Confirmation.create({model: model, property: 'attribute', options: options});
    // set(model, 'attribute', 'test');
    // set(model, 'attributeConfirmation', 'test');
    // });
    // assert.deepEqual(validator.errors, []);
    // run(function() {
    // set(model, 'attributeConfirmation', 'newTest');
    // });
    // assert.deepEqual(validator.errors, ['failed validation']);
    // run(function() {
    // set(model, 'attribute', 'newTest');
    // });
    // assert.deepEqual(validator.errors, []);
  });

  // test('when values do not match', function(assert) {
  // let model = this.subject();

  // options = { message: 'failed validation' };
  // run(function() {
  // validator = Confirmation.create({model: model, property: 'attribute', options: options});
  // set(model, 'attribute', 'test');
  // });
  // assert.deepEqual(validator.errors, ['failed validation']);
  // });

  // test('when original is null', function(assert) {
  // let model = this.subject();

  // run(function() {
  // validator = Confirmation.create({model: model, property: 'attribute'});
  // model.set('attribute', null);
  // });
  // assert.ok(Ember.isEmpty(validator.errors));
  // });

  // test('when confirmation is null', function(assert) {
  // let model = this.subject();

  // run(function() {
  // validator = Confirmation.create({model: model, property: 'attribute'});
  // model.set('attributeConfirmation', null);
  // });
  // assert.ok(Ember.isEmpty(validator.errors));
  // });

  // test('when options is true', function(assert) {
  // let model = this.subject();

  // options = true;
  // run(function() {
  // validator = Confirmation.create({model: model, property: 'attribute', options: options});
  // set(model, 'attribute', 'test');
  // });
  // assert.deepEqual(validator.errors, ["doesn't match attribute"]);
  // });

  // test('message integration on model, prints message on Confirmation property', function(assert) {
  // let model = this.subject();

  // var otherModel, OtherModel = Model.extend({
  // validations: {
  // attribute: {
  // confirmation: true
  // }
  // }
  // });

  // run(function() {
  // otherModel = OtherModel.create();
  // set(otherModel, 'attribute', 'test');
  // });

  // assert.deepEqual(get(otherModel, 'errors.attributeConfirmation'), ["doesn't match attribute"]);
  // assert.deepEqual(get(otherModel, 'errors.attribute'), []);
  // });

});
define('dummy/tests/unit/validators/local/confirmation-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/local');
  test('unit/validators/local/confirmation-test.js should pass jshint', function() { 
    ok(true, 'unit/validators/local/confirmation-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/local/exclusion-test', ['ember', 'qunit', 'ember-validations/validators/local/exclusion', 'ember-validations/mixin'], function (Ember, qunit, Exclusion, Mixin) {

  'use strict';

  var model, Model, options, validator;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Exclusion Validator', {
    setup: function setup() {
      Model = Ember['default'].Object.extend(Mixin['default']);
      run(function () {
        model = Model.create();
      });
    }
  });

  qunit.test('when value is not in the list', function (assert) {
    options = { 'message': 'failed validation', 'in': [1, 2, 3] };
    run(function () {
      validator = Exclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 4);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when value is in the list', function (assert) {
    options = { 'message': 'failed validation', 'in': [1, 2, 3] };
    run(function () {
      validator = Exclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when allowing blank', function (assert) {
    options = { 'message': 'failed validation', 'in': [1, 2, 3], allowBlank: true };
    run(function () {
      validator = Exclusion['default'].create({ model: model, property: 'attribute', options: options });
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when not allowing blank', function (assert) {
    options = { 'message': 'failed validation', 'in': [1, 2, 3] };
    run(function () {
      validator = Exclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when value is not in the range', function (assert) {
    options = { 'message': 'failed validation', 'range': [1, 3] };
    run(function () {
      validator = Exclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 4);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when value is in the range', function (assert) {
    options = { 'message': 'failed validation', 'range': [1, 3] };
    run(function () {
      validator = Exclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when options is an array', function (assert) {
    options = [1, 2, 3];
    run(function () {
      validator = Exclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['is reserved']);
  });

  qunit.test('when no message is passed', function (assert) {
    options = { 'in': [1, 2, 3] };
    run(function () {
      validator = Exclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['is reserved']);
  });

});
define('dummy/tests/unit/validators/local/exclusion-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/local');
  test('unit/validators/local/exclusion-test.js should pass jshint', function() { 
    ok(true, 'unit/validators/local/exclusion-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/local/format-test', ['ember', 'qunit', 'ember-validations/validators/local/format', 'ember-validations/mixin'], function (Ember, qunit, Format, Mixin) {

  'use strict';

  var model, Model, options, validator;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Format Validator', {
    setup: function setup() {
      Model = Ember['default'].Object.extend(Mixin['default']);
      run(function () {
        model = Model.create();
      });
    }
  });

  qunit.test('when matching format', function (assert) {
    options = { 'message': 'failed validation', 'with': /\d+/ };
    run(function () {
      validator = Format['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '123');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when not matching format', function (assert) {
    options = { 'message': 'failed validation', 'with': /\d+/ };
    run(function () {
      validator = Format['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 'abc');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when allowing blank', function (assert) {
    options = { 'message': 'failed validation', 'with': /\d+/, 'allowBlank': true };
    run(function () {
      validator = Format['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when not allowing blank', function (assert) {
    options = { 'message': 'failed validation', 'with': /\d+/ };
    run(function () {
      validator = Format['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when options is regexp', function (assert) {
    options = /\d+/;
    run(function () {
      validator = Format['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['is invalid']);
  });

  qunit.test('when no message is passed', function (assert) {
    options = { 'with': /\d+/ };
    run(function () {
      validator = Format['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['is invalid']);
  });

});
define('dummy/tests/unit/validators/local/format-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/local');
  test('unit/validators/local/format-test.js should pass jshint', function() { 
    ok(true, 'unit/validators/local/format-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/local/inclusion-test', ['ember', 'qunit', 'ember-validations/validators/local/inclusion', 'ember-validations/mixin'], function (Ember, qunit, Inclusion, Mixin) {

  'use strict';

  var model, Model, options, validator;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Inclusion Validator', {
    setup: function setup() {
      Model = Ember['default'].Object.extend(Mixin['default']);
      run(function () {
        model = Model.create();
      });
    }
  });

  qunit.test('when value is in the list', function (assert) {
    options = { 'message': 'failed validation', 'in': [1, 2, 3] };
    run(function () {
      validator = Inclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when value is not in the list', function (assert) {
    options = { 'message': 'failed validation', 'in': [1, 2, 3] };
    run(function () {
      validator = Inclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 4);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when allowing blank', function (assert) {
    options = { 'message': 'failed validation', 'in': [1, 2, 3], allowBlank: true };
    run(function () {
      validator = Inclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when not allowing blank', function (assert) {
    options = { 'message': 'failed validation', 'in': [1, 2, 3] };
    run(function () {
      validator = Inclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when value is in the range', function (assert) {
    options = { 'message': 'failed validation', 'range': [1, 3] };
    run(function () {
      validator = Inclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when value is not in the range', function (assert) {
    options = { 'message': 'failed validation', 'range': [1, 3] };
    run(function () {
      validator = Inclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 4);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when options is array', function (assert) {
    options = [1, 2, 3];
    run(function () {
      validator = Inclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['is not included in the list']);
  });

  qunit.test('when no message is passed', function (assert) {
    options = { 'in': [1, 2, 3] };
    run(function () {
      validator = Inclusion['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['is not included in the list']);
  });

});
define('dummy/tests/unit/validators/local/inclusion-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/local');
  test('unit/validators/local/inclusion-test.js should pass jshint', function() { 
    ok(true, 'unit/validators/local/inclusion-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/local/length-test', ['ember', 'qunit', 'ember-validations/validators/local/length', 'ember-validations/mixin'], function (Ember, qunit, Length, Mixin) {

  'use strict';

  var model, Model, options, validator;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Length Validator', {
    setup: function setup() {
      Model = Ember['default'].Object.extend(Mixin['default']);
      run(function () {
        model = Model.create();
      });
    }
  });

  qunit.test('when allowed length is 3 and value length is 3', function (assert) {
    options = { messages: { wrongLength: 'failed validation' }, is: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '123');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when allowed length is 3 and value length is 4', function (assert) {
    options = { messages: { wrongLength: 'failed validation' }, is: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '1234');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when allowed length is 3 and value length is 2', function (assert) {
    options = { messages: { wrongLength: 'failed validation' }, is: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '12');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when allowing blank and allowed length is 3', function (assert) {
    options = { messages: { wrongLength: 'failed validation' }, is: 3, allowBlank: true };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when allowing blank and minimum length is 3 and maximum length is 100', function (assert) {
    options = { messages: { tooShort: 'failed minimum validation', tooLong: 'failed maximum validation' }, minimum: 3, maximum: 100, allowBlank: true };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when not allowing blank and allowed length is 3', function (assert) {
    options = { messages: { wrongLength: 'failed validation' }, is: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when allowed length is 3 and a different tokenizer', function (assert) {
    options = { messages: { wrongLength: 'failed validation' }, is: 3, tokenizer: function tokenizer(value) {
        return value.split(' ');
      } };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 'one two three');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when allowed length minimum is 3 and value length is 3', function (assert) {
    options = { messages: { wrongLength: 'failed validation' }, is: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '123');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when allowed length minimum is 3 and value length is 2', function (assert) {
    options = { messages: { tooShort: 'failed validation' }, minimum: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '12');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when allowed length maximum is 3 and value length is 3', function (assert) {
    options = { messages: { wrongLength: 'failed validation' }, is: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '123');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when allowed length maximum is 3 and value length is 4', function (assert) {
    options = { messages: { tooLong: 'failed validation' }, maximum: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '1234');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when allowed length maximum is 3 and value is blank', function (assert) {
    options = { maximum: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when options is a number', function (assert) {
    set(model, 'attribute', '1234');
    options = 3;
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['is the wrong length (should be 3 characters)']);
  });

  qunit.test('when options is a number and value is undefined', function (assert) {
    options = 3;
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['is the wrong length (should be 3 characters)']);
  });

  qunit.test('when allowed length is 3, value length is 4 and no message is set', function (assert) {
    options = { is: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '1234');
    });
    assert.deepEqual(validator.errors, ['is the wrong length (should be 3 characters)']);
  });

  qunit.test('when allowed length minimum is 3, value length is 2 and no message is set', function (assert) {
    options = { minimum: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '12');
    });
    assert.deepEqual(validator.errors, ['is too short (minimum is 3 characters)']);
  });

  qunit.test('when allowed length maximum is 3, value length is 4 and no message is set', function (assert) {
    options = { maximum: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '1234');
    });
    assert.deepEqual(validator.errors, ['is too long (maximum is 3 characters)']);
  });

  qunit.test('when value is non-string, then the value is still checked', function (assert) {
    options = { maximum: 3 };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1234);
    });
    assert.deepEqual(validator.errors, ['is too long (maximum is 3 characters)']);
  });

  qunit.test('when using a property instead of a number', function (assert) {
    options = { is: 'countProperty' };
    run(function () {
      validator = Length['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '123');
    });
    assert.deepEqual(validator.errors, ['is the wrong length (should be 0 characters)']);
    run(function () {
      set(model, 'countProperty', 3);
    });
    assert.deepEqual(validator.errors, []);
    run(function () {
      set(model, 'countProperty', 5);
    });
    assert.deepEqual(validator.errors, ['is the wrong length (should be 5 characters)']);
  });

});
define('dummy/tests/unit/validators/local/length-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/local');
  test('unit/validators/local/length-test.js should pass jshint', function() { 
    ok(true, 'unit/validators/local/length-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/local/numericality-test', ['ember', 'qunit', 'ember-validations/validators/local/numericality', 'ember-validations/mixin'], function (Ember, qunit, Numericality, Mixin) {

  'use strict';

  var model, Model, options, validator;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Numericality Validator', {
    setup: function setup() {
      Model = Ember['default'].Object.extend(Mixin['default']);
      run(function () {
        model = Model.create();
      });
    }
  });

  qunit.test('when value is a number', function (assert) {
    options = { messages: { numericality: 'failed validation' } };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 123);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when value is a decimal number', function (assert) {
    options = { messages: { numericality: 'failed validation' } };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 123.456);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when value is not a number', function (assert) {
    options = { messages: { numericality: 'failed validation' } };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 'abc123');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when no value', function (assert) {
    options = { messages: { numericality: 'failed validation' } };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when no value and allowing blank', function (assert) {
    options = { messages: { numericality: 'failed validation' }, allowBlank: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when bad value and allowing blank', function (assert) {
    options = { messages: { numericality: 'failed validation' }, allowBlank: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 'abc123');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when only allowing integers and value is integer', function (assert) {
    options = { messages: { onlyInteger: 'failed validation', numericality: 'failed validation' }, onlyInteger: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 123);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when only allowing integers and value is not integer', function (assert) {
    options = { messages: { onlyInteger: 'failed integer validation', numericality: 'failed validation' }, onlyInteger: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 123.456);
    });
    assert.deepEqual(validator.errors, ['failed integer validation']);
  });

  qunit.test('when only integer and no message is passed', function (assert) {
    options = { onlyInteger: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1.1);
    });
    assert.deepEqual(validator.errors, ['must be an integer']);
  });

  qunit.test('when only integer is passed directly', function (assert) {
    options = 'onlyInteger';
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1.1);
    });
    assert.deepEqual(validator.errors, ['must be an integer']);
  });

  qunit.test('when only allowing values greater than 10 and value is greater than 10', function (assert) {
    options = { messages: { greaterThan: 'failed validation', numericality: 'failed validation' }, greaterThan: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 11);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when only allowing values greater than 10 and value is 10', function (assert) {
    options = { messages: { greaterThan: 'failed validation', numericality: 'failed validation' }, greaterThan: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when only allowing values greater than or assert.deepEqual to 10 and value is 10', function (assert) {
    options = { messages: { greaterThanOrEqualTo: 'failed validation', numericality: 'failed validation' }, greaterThanOrEqualTo: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when only allowing values greater than or assert.deepEqual to 10 and value is 9', function (assert) {
    options = { messages: { greaterThanOrEqualTo: 'failed validation', numericality: 'failed validation' }, greaterThanOrEqualTo: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 9);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when only allowing values less than 10 and value is less than 10', function (assert) {
    options = { messages: { lessThan: 'failed validation', numericality: 'failed validation' }, lessThan: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 9);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when only allowing values less than 10 and value is 10', function (assert) {
    options = { messages: { lessThan: 'failed validation', numericality: 'failed validation' }, lessThan: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when only allowing values less than or assert.deepEqual to 10 and value is 10', function (assert) {
    options = { messages: { lessThanOrEqualTo: 'failed validation', numericality: 'failed validation' }, lessThanOrEqualTo: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when only allowing values less than or assert.deepEqual to 10 and value is 11', function (assert) {
    options = { messages: { lessThanOrEqualTo: 'failed validation', numericality: 'failed validation' }, lessThanOrEqualTo: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 11);
      assert.deepEqual(validator.errors, ['failed validation']);
    });
  });

  qunit.test('when only allowing values equal to 10 and value is 10', function (assert) {
    options = { messages: { equalTo: 'failed validation', numericality: 'failed validation' }, equalTo: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when only allowing values equal to 10 and value is 11', function (assert) {
    options = { messages: { equalTo: 'failed equal validation', numericality: 'failed validation' }, equalTo: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 11);
    });
    assert.deepEqual(validator.errors, ['failed equal validation']);
  });

  qunit.test('when only allowing value equal to 0 and value is 1', function (assert) {
    options = { messages: { equalTo: 'failed equal validation', numericality: 'failed validation' }, equalTo: 0 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 1);
    });
    assert.deepEqual(validator.errors, ['failed equal validation']);
  });

  qunit.test('when only allowing odd values and the value is odd', function (assert) {
    options = { messages: { odd: 'failed validation', numericality: 'failed validation' }, odd: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 11);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when only allowing odd values and the value is even', function (assert) {
    options = { messages: { odd: 'failed validation', numericality: 'failed validation' }, odd: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when only allowing even values and the value is even', function (assert) {
    options = { messages: { even: 'failed validation', numericality: 'failed validation' }, even: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when only allowing even values and the value is odd', function (assert) {
    options = { messages: { even: 'failed validation', numericality: 'failed validation' }, even: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 11);
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when value refers to another present property', function (assert) {
    options = { messages: { greaterThan: 'failed to be greater', numericality: 'failed validation' }, greaterThan: 'attribute_2' };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute_1', options: options });
      set(model, 'attribute_1', 0);
      set(model, 'attribute_2', 1);
    });
    assert.deepEqual(validator.errors, ['failed to be greater']);
    run(function () {
      set(model, 'attribute_1', 2);
      set(model, 'attribute_2', 1);
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when options is true', function (assert) {
    options = true;
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['is not a number']);
  });

  qunit.test('when equal to  and no message is passed', function (assert) {
    options = { equalTo: 11 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, ['must be equal to 11']);
  });

  qunit.test('when greater than and no message is passed', function (assert) {
    options = { greaterThan: 11 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, ['must be greater than 11']);
  });

  qunit.test('when greater than or equal to and no message is passed', function (assert) {
    options = { greaterThanOrEqualTo: 11 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, ['must be greater than or equal to 11']);
  });

  qunit.test('when less than and no message is passed', function (assert) {
    options = { lessThan: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 11);
    });
    assert.deepEqual(validator.errors, ['must be less than 10']);
  });

  qunit.test('when less than or equal to and no message is passed', function (assert) {
    options = { lessThanOrEqualTo: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 11);
    });
    assert.deepEqual(validator.errors, ['must be less than or equal to 10']);
  });

  qunit.test('when odd and no message is passed', function (assert) {
    options = { odd: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 10);
    });
    assert.deepEqual(validator.errors, ['must be odd']);
  });

  qunit.test('when even and no message is passed', function (assert) {
    options = { even: true };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 11);
    });
    assert.deepEqual(validator.errors, ['must be even']);
  });

  qunit.test('when other messages are passed but not a numericality message', function (assert) {
    options = { messages: { greaterThan: 'failed validation' } };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 'abc');
    });
    assert.deepEqual(validator.errors, ['is not a number']);
  });

  qunit.test('when greaterThan fails and a greaterThan message is passed but not a numericality message', function (assert) {
    options = { greaterThan: 11, messages: { greaterThan: 'custom message' } };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      model.set('attribute', 10);
    });
    assert.deepEqual(validator.errors, ['custom message']);
  });

  qunit.test('numericality validators don\'t call addObserver on null props', function (assert) {
    var stubbedObserverCalls = 0;

    var realAddObserver = model.addObserver;
    model.addObserver = function (_, path) {
      stubbedObserverCalls += 1;
      if (!path) {
        assert.ok(false, 'shouldn\'t call addObserver with falsy path');
      }
      return realAddObserver.apply(this, arguments);
    };

    options = { lessThanOrEqualTo: 10 };
    run(function () {
      validator = Numericality['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 11);
    });
    model.addObserver = realAddObserver;

    assert.equal(1, stubbedObserverCalls, 'stubbed addObserver was called');
  });

});
define('dummy/tests/unit/validators/local/numericality-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/local');
  test('unit/validators/local/numericality-test.js should pass jshint', function() { 
    ok(true, 'unit/validators/local/numericality-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/local/presence-test', ['ember', 'qunit', 'ember-validations/validators/local/presence', 'ember-validations/mixin'], function (Ember, qunit, Presence, Mixin) {

  'use strict';

  var model, Model, options, validator;
  var set = Ember['default'].set;
  var run = Ember['default'].run;

  qunit.module('Presence Validator', {
    setup: function setup() {
      Model = Ember['default'].Object.extend(Mixin['default']);
      run(function () {
        model = Model.create();
      });
    }
  });

  qunit.test('when value is not empty', function (assert) {
    options = { message: 'failed validation' };
    run(function () {
      validator = Presence['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', 'not empty');
    });
    assert.deepEqual(validator.errors, []);
  });

  qunit.test('when value is empty', function (assert) {
    options = { message: 'failed validation' };
    run(function () {
      validator = Presence['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

  qunit.test('when options is true', function (assert) {
    options = true;
    run(function () {
      validator = Presence['default'].create({ model: model, property: 'attribute', options: options });
      set(model, 'attribute', '');
    });
    assert.deepEqual(validator.errors, ['can\'t be blank']);
  });

  qunit.test('when value is blank', function (assert) {
    options = { message: 'failed validation' };
    run(function () {
      validator = Presence['default'].create({ model: model, property: 'attribute', options: options });
      model.set('attribute', ' ');
    });
    assert.deepEqual(validator.errors, ['failed validation']);
  });

});
define('dummy/tests/unit/validators/local/presence-test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/local');
  test('unit/validators/local/presence-test.js should pass jshint', function() { 
    ok(true, 'unit/validators/local/presence-test.js should pass jshint.'); 
  });

});
define('dummy/tests/unit/validators/remote/uniqueness_test', function () {

	'use strict';

	if (false) {} // remove this line. It is only here to fix issue #232
	// module('Uniqueness options', {
	// setup: function() {
	// Ember.Validations.forms['new_user'] = {
	// type: 'ActionView::Helpers::FormBuilder',
	// input_tag: '<div class="field_with_errors"><span id="input_tag" /><label class="message"></label></div>',
	// label_tag: '<div class="field_with_errors"><label id="label_tag" /></div>',
	// validators: {'user[email]':{"uniqueness":[{"message": "must be unique", "scope":{'name':"pass"}}]},"presence":[{"message": "must be present"}]}
	// }

	// $('#qunit-fixture')
	// .append($('<form />', {
	// action: '/users',
	// 'data-validate': true,
	// method: 'post',
	// id: 'new_user'
	// }))
	// .find('form')
	// .append($('<input />', {
	// name: 'user[name]',
	// id: 'user_name',
	// type: 'text'
	// }))
	// .append($('<input />', {
	// name: 'user[email]',
	// id: 'user_email',
	// type: 'text'
	// }))

	// $('form#new_user').call();
	// }
	// });

	// test('when matching uniqueness on a non-nested resource', function() {
	// var element = $('<input type="text" name="user[email]"/>');
	// var options = { 'message': "failed validation" };
	// element.val('nottaken@test.com');
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), undefined);
	// });

	// test('when matching uniqueness on a non-nested resource', function() {
	// var element = $('<input type="text" name="user[email]"/>');
	// var options = { 'message': "failed validation" };
	// element.val('taken@test.com');
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), "failed validation");
	// });

	// test('when matching uniqueness on a nested singular resource', function() {
	// var element = $('<input type="text" name="profile[user_attributes][email]"/>');
	// var options = { 'message': "failed validation" };
	// element.val('nottaken@test.com');
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), undefined);
	// });

	// test('when matching uniqueness on a nested singular resource', function() {
	// var element = $('<input type="text" name="profile[user_attributes][email]"/>');
	// var options = { 'message': "failed validation" };
	// element.val('taken@test.com');
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), "failed validation");
	// });

	// test('when using scopes with no replacement', function() {
	// var element = $('<input type="text" name="person[age]" />');
	// var options = { 'message': "failed validation", 'with': /\d+/, 'scope': { 'name': 'test name' } };
	// element.val('test');
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), "failed validation");
	// });

	// test('when using scopes with replacement', function() {
	// var element = $('<input type="text" name="person[age]" />');
	// var options = { 'message': "failed validation", 'with': /\d+/, 'scope': { 'name': 'test name' } };
	// element.val('test')
	// $('#qunit-fixture').append('<input type="text" name="person[name]" />').find('input[name="person[name]"]').val('other name');
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), undefined);
	// });

	// test('when validating by scope and mixed focus order', function() {
	// var unique_element = $('#user_email'), scope_element = $('#user_name');
	// unique_element.val('free@test.com');
	// unique_element.trigger('change');
	// unique_element.trigger('focusout');
	// equal($('.message[for="user_email"]').text(), '');

	// scope_element.val('test name');
	// scope_element.trigger('change');
	// scope_element.trigger('focusout');
	// equal($('.message[for="user_email"]').text(), 'must be unique');
	// });

	// test('when using scopes with replacement as checkboxes', function() {
	// var element = $('<input type="text" name="person[age]" />');
	// var options = { 'message': "failed validation", 'with': /\d+/, 'scope': { 'name': 'test name' } };
	// element.val('test')
	// $('#qunit-fixture')
	// .append('<input type="hidden" name="person[name]" value="other name"')
	// .append('<input type="checkbox" name="person[name]" value="test name"/>')
	// .find('input[name="person[name]"]').val('other name');
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), undefined);
	// $('[name="person[name]"]:checkbox')[0].checked = true;
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), 'failed validation');
	// });

	// test('when matching uniqueness on a resource with a defined class name', function() {
	// var element = $('<input type="text" name="user2[email]"/>');
	// var options = { 'message': "failed validation", 'class': "active_record_test_module/user2" };
	// element.val('nottaken@test.com');
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), 'failed validation');
	// });

	// test('when allowing blank', function() {
	// var element = $('<input type="text" name="user2[email]" />');
	// var options = { 'message': "failed validation", 'with': /\d+/, 'allowBlank': true };
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), undefined);
	// });

	// test('when not allowing blank', function() {
	// var element = $('<input type="text" name="user2[email]" />');
	// var options = { 'message': "failed validation", 'with': /\d+/ };
	// equal(Ember.Validations.validators.remote.uniqueness(model, property, options), "failed validation");
	// });

	// test('when matching local uniqueness for nested has-many resources', function() {
	// $('#qunit-fixture')
	// .append($('<form />', {
	// action: '/users',
	// 'data-validate': true,
	// method: 'post',
	// id: 'new_user_2'
	// }))
	// .find('form')
	// .append($('<input />', {
	// name: 'profile[user_attributes][0][email]',
	// id: 'user_0_email',
	// }))
	// .append($('<input />', {
	// name: 'profile[user_attributes][1][email]',
	// id: 'user_1_email',
	// }));

	// Ember.Validations.forms['new_user_2'] = {
	// type: 'ActionView::Helpers::FormBuilder',
	// input_tag: '<div class="field_with_errors"><span id="input_tag" /><label for="user_name" class="message"></label></div>',
	// label_tag: '<div class="field_with_errors"><label id="label_tag" /></div>',
	// validators: { 'user[email]':{"uniqueness":[{"message": "must be unique"}]}}
	// }
	// $('form#new_user_2').call();

	// var user_0_email = $('#user_0_email'),
	// user_1_email = $('#user_1_email'),
	// options = { 'message': "must be unique" };

	// user_0_email.val('not-locally-unique');
	// user_1_email.val('not-locally-unique');

	// equal(Ember.Validations.validators.remote.uniqueness(user_1_email, options), undefined);
	// equal(Ember.Validations.validators.local.uniqueness(user_1_email, options), "must be unique");
	// });

});
define('dummy/tests/unit/validators/remote/uniqueness_test.jshint', function () {

  'use strict';

  module('JSHint - unit/validators/remote');
  test('unit/validators/remote/uniqueness_test.js should pass jshint', function() { 
    ok(true, 'unit/validators/remote/uniqueness_test.js should pass jshint.'); 
  });

});
/* jshint ignore:start */

/* jshint ignore:end */

/* jshint ignore:start */

define('dummy/config/environment', ['ember'], function(Ember) {
  var prefix = 'dummy';
/* jshint ignore:start */

try {
  var metaName = prefix + '/config/environment';
  var rawConfig = Ember['default'].$('meta[name="' + metaName + '"]').attr('content');
  var config = JSON.parse(unescape(rawConfig));

  return { 'default': config };
}
catch(err) {
  throw new Error('Could not read config from meta tag with name "' + metaName + '".');
}

/* jshint ignore:end */

});

if (runningTests) {
  require("dummy/tests/test-helper");
} else {
  require("dummy/app")["default"].create({"name":"ember-validations","version":"2.0.0-alpha.3.15fafa42"});
}

/* jshint ignore:end */
//# sourceMappingURL=dummy.map